{
  "name": "Japs",
  "tagline": "JaPS is a robust and lightweight Java Pub/Sub library which uses JSON.",
  "body": "# JaPS\r\n\r\nI have started this project to learn myself how Pub/Sub libraries can work and it has turned out that JaPS works really well,\r\ntherefore I have decided to publish it here on GitHub.\r\n\r\n# Features\r\n\r\n- channels\r\n- channel handler (json object and custom object)\r\n- key-value based handler method invocation\r\n- subscriber may have custom names\r\n- publish to specific subscriber\r\n- custom object serialization with [gson] (https://github.com/google/gson)\r\n- clean API\r\n- extensive API\r\n- low cpu and memory consumption\r\n- lightweight\r\n- scalable\r\n- simple JSON\r\n- easy to implement in other languages (PHP publisher example at to bottom)\r\n- async publishing via the AsyncPublisher\r\n- full multi-core utilization and configurable number of threads\r\n- combine multiple JaPS server to a cluster\r\n- cluster failover with auto reconnect and sync\r\n- simple but powerful NIO implementation\r\n- thousands of publisher and subscriber concurrently\r\n- hundreds of new connections per second\r\n\r\n# Installation\r\n\r\n- Install [Maven 3](http://maven.apache.org/download.cgi)\r\n- Clone/Download this repo\r\n- Install it with: ```mvn clean install```\r\n\r\n**Maven dependencies**\r\n\r\n_Client:_\r\n```xml\r\n<dependency>\r\n    <groupId>de.jackwhite20</groupId>\r\n    <artifactId>japs-client</artifactId>\r\n    <version>0.1-SNAPSHOT</version>\r\n</dependency>\r\n```\r\n\r\n# Quick start\r\n\r\n_Publisher:_\r\n```java\r\nPublisher publisher = PublisherFactory.create(\"localhost\", 1337);\r\n\r\nJSONObject fooBar = new JSONObject();\r\nfooBar.put(\"foo\", \"bar\");\r\npublisher.publish(\"test\", fooBar);\r\n\r\n// Both will work\r\npublisher.publish(\"gson\", fooBar);\r\npublisher.publish(\"gson\", new FooBar(\"bar\"));\r\n\r\nJSONObject backendJson = new JSONObject();\r\nbackendJson.put(\"role\", \"update\");\r\nbackendJson.put(\"ping\", 5);\r\npublisher.publish(\"backend\", backendJson);\r\n\r\n// Publish to a channel and a specific subscriber\r\npublisher.publish(\"test\", \"some-subscriber\", fooBar);\r\n\r\n// Publish multiple json objects to a channel\r\npublisher.publishAll(\"test\", jsonObject, new JSONObject().put(\"foo\", \"second\"));\r\n\r\n// Publish multiple json objects to a channel and a specific subscriber\r\npublisher.publishAll(\"test\", \"some-subscriber\", jsonObject, new JSONObject().put(\"foo\", \"second\"));\r\n\r\n// Publish multiple objects to a channel\r\npublisher.publishAll(\"gson\", new FooBar(\"bar\"), new FooBar(\"bar2\"));\r\n\r\n// Publish multiple objects to a channel and a specific subscriber\r\npublisher.publishAll(\"gson\", \"some-subscriber\", new FooBar(\"bar\"), new FooBar(\"bar2\"));\r\n\r\n// You need to publish something async because you don't want to block your main thread perhaps?\r\n// Here you go\r\nAsyncPublisher asyncPublisher = publisher.async();\r\nasyncPublisher.publish(\"test\", fooBar);\r\n\r\n// True because we want to force the disconnect so that it will not try to reconnect to the cluster\r\npublisher.disconnect(true);\r\n```\r\n\r\n_Subscriber:_\r\n```java\r\nSubscriber subscriber = SubscriberFactory.create(\"localhost\", 1337);\r\nsubscriber.subscribe(TestChannelHandler.class);\r\nsubscriber.subscribeMulti(BackendMultiChannelHandler.class);\r\nsubscriber.subscribe(GsonChannelHandler.class);\r\n\r\n// True because we want to force the disconnect so that it will not try to reconnect to the cluster\r\nsubscriber.disconnect(true);\r\n```\r\n\r\n_Subscriber with defined name:_\r\n```java\r\nSubscriber subscriber = SubscriberFactory.create(\"localhost\", 1337, \"some-subscriber\");\r\nsubscriber.subscribe(\"test\", TestChannelHandler.class);\r\n```\r\n\r\n_TestChannelHandler:_\r\n```java\r\n@Channel(\"test\")\r\npublic class TestChannelHandler extends ChannelHandler<JSONObject> {\r\n\r\n    @Override\r\n    public void onMessage(String channel, JSONObject message) {\r\n\r\n        System.out.println(\"TestChannelHandler: foo=\" + message.get(\"foo\"));\r\n    }\r\n}\r\n```\r\n\r\n_BackendMultiChannelHandler:_\r\n```java\r\n@Channel(\"backend\")\r\npublic class BackendMultiChannelHandler {\r\n\r\n    @Key(\"role\")\r\n    @Value(\"update\")\r\n    public void onBackendRoleUpdate(JSONObject jsonObject) {\r\n\r\n\t\t// Keep in mind that the key (here \"role\") will be removed before invocation\r\n        System.out.println(\"BMCH[role=update]: ping=\" + jsonObject.getInt(\"ping\"));\r\n    }\r\n    \r\n    @Key(\"role\")\r\n    @Value(\"delete\")\r\n    public void onBackendRoleDelete(FooBar fooBar) {\r\n\r\n        System.out.println(\"FooBar[role=delete]: \" + fooBar.toString());\r\n    }\r\n}\r\n```\r\n\r\n_GsonChannelHandler:_\r\n```java\r\n@Channel(\"gson\")\r\npublic class GsonChannelHandler extends ChannelHandler<FooBar> {\r\n\r\n    @Override\r\n    public void onMessage(String channel, FooBar fooBar) {\r\n\r\n        System.out.println(\"FooBar class: \" + fooBar.toString());\r\n    }\r\n}\r\n```\r\n\r\n_The simple FooBar class:_\r\n```java\r\npublic class FooBar {\r\n\r\n\tprivate String foo;\r\n\r\n    public FooBar(String foo) {\r\n\r\n        this.foo = foo;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n\r\n        return \"FooBar{\" +\r\n                \"foo='\" + foo + '\\'' +\r\n                '}';\r\n    }\r\n}\r\n```\r\n\r\n# PHP example\r\n\r\n_JaPSPublisher:_\r\n```php\r\n<?php\r\n\r\nclass JaPSPublisher\r\n{\r\n\r\n    /**\r\n     * Host address.\r\n     *\r\n     * @var string The host address.\r\n     */\r\n    private $host;\r\n\r\n    /**\r\n     * Host port.\r\n     *\r\n     * @var int The host port.\r\n     */\r\n    private $port;\r\n\r\n    /**\r\n     * Socket instance.\r\n     *\r\n     * @var resource The socket instance.\r\n     */\r\n    private $socket;\r\n\r\n    /**\r\n     * JaPSPublisher constructor.\r\n     */\r\n    /**\r\n     * JaPSPublisher constructor.\r\n     *\r\n     * @param string $host The host address to connect to.\r\n     * @param int $port The host port to connect to.\r\n     */\r\n    public function __construct($host = \"localhost\", $port = 1337)\r\n    {\r\n        $this->host = $host;\r\n        $this->port = $port;\r\n\r\n        $this->socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);\r\n\r\n        $this->connect();\r\n    }\r\n\r\n    /**\r\n     * Connects the internal socket.\r\n     */\r\n    private function connect() {\r\n\r\n        socket_connect($this->socket, $this->host, $this->port);\r\n    }\r\n\r\n    /**\r\n     * Publish a message to a given channel.\r\n     *\r\n     * @param ($channel) The channel.\r\n     * @param ($array) The message as an array which will be json encoded.\r\n     */\r\n    public function publish($channel, $array) {\r\n\r\n        $array['op'] = 2;\r\n        $array['ch'] = $channel;\r\n\r\n        $json = json_encode($array);\r\n        $jsonLength = strlen($json);\r\n        $length = pack('N', $jsonLength);\r\n\r\n        socket_write($this->socket, $length . $json, $jsonLength + 4);\r\n    }\r\n\r\n    /**\r\n     * Closes the publisher.\r\n     */\r\n    public function close() {\r\n\r\n        socket_close($this->socket);\r\n    }\r\n}\r\n```\r\n\r\n_Example usage:_\r\n```php\r\n<?php\r\n\r\ninclude(\"JaPSPublisher.php\");\r\n\r\n$client = new JaPSPublisher(\"192.168.2.102\", 6000);\r\n\r\n$client->publish(\"test\", array(\"foo\" => \"bar1\"));\r\n$client->publish(\"test\", array(\"foo\" => \"bar2\"));\r\n\r\n$client->close();\r\n```\r\n\r\n### License\r\n\r\nLicensed under the GNU General Public License, Version 3.0.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}