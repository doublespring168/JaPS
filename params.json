{
  "name": "JaPS",
  "tagline": "JaPS is a robust and lightweight Java Pub/Sub library and in-memory key-value cache which uses JSON.",
  "body": "# JaPS\r\n\r\nI have started this project to learn myself how Pub/Sub libraries can work and it has turned out that JaPS works really well,\r\ntherefore I have decided to publish it here on GitHub.\r\n\r\nJaPS now has also memory snapshot support to create a backup of cached data or to use it as a \"persistent\" memory database.\r\n\r\n# Features\r\n\r\n- in-memory key-value cache (based on json, so class serialization possible)\r\n- cache memory snapshots\r\n- channels\r\n- channel handler (json object and custom object)\r\n- key-value based handler method invocation\r\n- subscriber may have custom names\r\n- publish to specific subscriber\r\n- custom object serialization with [gson] (https://github.com/google/gson)\r\n- clean API\r\n- extensive API\r\n- low cpu and memory consumption\r\n- lightweight\r\n- scalable\r\n- simple JSON\r\n- easy to implement in other languages (PHP publisher example at the bottom)\r\n- async API support\r\n- full multi-core utilization and configurable number of threads\r\n- combine multiple JaPS server to a cluster\r\n- cluster failover with auto reconnect and sync\r\n- simple but powerful NIO implementation\r\n- thousands of publisher and subscriber concurrently\r\n- hundreds of new connections per second\r\n\r\n# Installation\r\n\r\n- Install [Maven 3](http://maven.apache.org/download.cgi)\r\n- Clone/Download this repo\r\n- Install it with: ```mvn clean install```\r\n\r\n**Maven dependencies**\r\n\r\n_Client:_\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>de.jackwhite20</groupId>\r\n    <artifactId>japs-client</artifactId>\r\n    <version>2.2.0-SNAPSHOT</version>\r\n</dependency>\r\n```\r\n\r\n# Server start with the CLI\r\n\r\n_General syntax:_\r\n\r\n```\r\njava -jar japs-server.jar -h <Host> -p <Port> -b <Backlog> -t <Threads> [-c IP:Port IP:Port] [-d]\r\n```\r\n\r\n_Without debugging and without cluster setup:_\r\n\r\n```\r\njava -jar japs-server.jar -h localhost -p 1337 -b 100 -t 4\r\n```\r\n\r\n_With debugging and without cluster setup:_\r\n\r\n```\r\njava -jar japs-server.jar -h localhost -p 1337 -b 100 -t 4 -d\r\n```\r\n\r\n_With debugging and with cluster setup:_\r\n\r\n```\r\njava -jar japs-server.jar -h localhost -p 1337 -b 100 -t 4 -c localhost:1338 -d\r\n```\r\n\r\n_Set the check (ci) or snapshot (si) interval:_\r\n\r\n```\r\n// Both are in seconds\r\n// This will check the cache for expired entries every 10 minutes\r\n// and will take a memory snapshot (backup) every hour\r\njava -jar japs-server.jar -h localhost -p 1337 -b 100 -t 4 -c localhost:1338 -d -ci 600 -si 3600\r\n```\r\n\r\n# API examples\r\n\r\nIf you want to use the javadoc you can browse it [here](https://jackwhite20.github.io/JaPS/doc/).\r\n\r\n_Cache:_\r\n```java\r\nPubSubCache cache = PubSubCacheFactory.create(\"localhost\", 1337);\r\n// To create a pub sub cache from a cluster\r\n//PubSubCache cache = PubSubCacheFactory.create(Arrays.asList(new ClusterServer(\"localhost\", 1337), new ClusterServer(\"localhost\", 1338)));\r\n\r\ncache.put(\"json\", new JSONObject().put(\"foo\", \"bar\"));\r\ncache.get(\"json\", jsonObject -> System.out.println(\"Foo: \" + jsonObject.get(\"foo\")));\r\ncache.async().get(\"json\", jsonObject -> System.out.println(\"Foo: \" + jsonObject.get(\"foo\")));\r\n\r\n// The class needs to implement the 'Cacheable' interface to be serialized to json\r\n// Key will expire in 5 seconds\r\ncache.put(\"test\", new FooBar(\"Some text\"), 5);\r\ncache.get(\"test\", json -> System.out.println(\"FooBar class: \" + json.toString()));\r\n\r\n// Gets the time in seconds how long the key lives until it's expired\r\ncache.expire(\"test\", System.out::println);\r\n\r\ntry {\r\n\tThread.sleep(1000);\r\n} catch (InterruptedException e) {\r\n\te.printStackTrace();\r\n}\r\n\r\ncache.expire(\"test\", System.out::println);\r\n\r\n// Gets the class instance of the given class from the key\r\ncache.getClass(\"test\", fooBar -> System.out.println(\"Foo: \" + fooBar.getFoo()), FooBar.class);\r\n// The same as above but without lambda\r\n/*cache.getClass(\"test\", new Consumer<FooBar>() {\r\n\r\n\t@Override\r\n\tpublic void accept(FooBar fooBar) {\r\n\r\n\t\tSystem.out.println(fooBar);\r\n\t}\r\n}, FooBar.class);*/\r\n\r\n// Removes the key from the cache\r\ncache.remove(\"json\");\r\n\r\n// Disconnects the cache client\r\ncache.disconnect();\r\n```\r\n\r\n_Publisher:_\r\n```java\r\nPublisher publisher = PublisherFactory.create(\"localhost\", 1337);\r\n// To create a publisher from a cluster\r\n//Publisher publisher = PublisherFactory.create(Arrays.asList(new ClusterServer(\"localhost\", 1337), new ClusterServer(\"localhost\", 1338)));\r\n\r\nJSONObject fooBar = new JSONObject();\r\nfooBar.put(\"foo\", \"bar\");\r\npublisher.publish(\"test\", fooBar);\r\n\r\n// Both will work\r\npublisher.publish(\"gson\", fooBar);\r\npublisher.publish(\"gson\", new FooBar(\"bar\"));\r\n\r\nJSONObject backendJson = new JSONObject();\r\nbackendJson.put(\"role\", \"update\");\r\nbackendJson.put(\"ping\", 5);\r\npublisher.publish(\"backend\", backendJson);\r\n\r\n// Publish to a channel and a specific subscriber\r\npublisher.publish(\"test\", \"some-subscriber\", fooBar);\r\n\r\n// Publish multiple json objects to a channel\r\npublisher.publishAll(\"test\", jsonObject, new JSONObject().put(\"foo\", \"second\"));\r\n\r\n// Publish multiple json objects to a channel and a specific subscriber\r\npublisher.publishAll(\"test\", \"some-subscriber\", jsonObject, new JSONObject().put(\"foo\", \"second\"));\r\n\r\n// Publish multiple objects to a channel\r\npublisher.publishAll(\"gson\", new FooBar(\"bar\"), new FooBar(\"bar2\"));\r\n\r\n// Publish multiple objects to a channel and a specific subscriber\r\npublisher.publishAll(\"gson\", \"some-subscriber\", new FooBar(\"bar\"), new FooBar(\"bar2\"));\r\n\r\n// You need to publish something async because you don't want to block your main thread perhaps?\r\n// Here you go\r\nAsyncPublisher asyncPublisher = publisher.async();\r\nasyncPublisher.publish(\"test\", fooBar);\r\n\r\n// True because we want to force the disconnect so that it will not try to reconnect to the cluster\r\npublisher.disconnect(true);\r\n// Is the same as\r\n//publisher.disconnect();\r\n```\r\n\r\n_Subscriber:_\r\n```java\r\nSubscriber subscriber = SubscriberFactory.create(\"localhost\", 1337);\r\n// To create a subscriber from a cluster\r\n//Subscriber subscriber = SubscriberFactory.create(Arrays.asList(new ClusterServer(\"localhost\", 1337), new ClusterServer(\"localhost\", 1338)), \"some-subscriber\");\r\nsubscriber.subscribe(TestChannelHandler.class);\r\nsubscriber.subscribeMulti(BackendMultiChannelHandler.class);\r\nsubscriber.subscribe(GsonChannelHandler.class);\r\n\r\n// True because we want to force the disconnect so that it will not try to reconnect to the cluster\r\nsubscriber.disconnect(true);\r\n// Is the same as\r\n//subscriber.disconnect();\r\n```\r\n\r\n_Subscriber with defined name:_\r\n```java\r\nSubscriber subscriber = SubscriberFactory.create(\"localhost\", 1337, \"some-subscriber\");\r\nsubscriber.subscribe(TestChannelHandler.class);\r\n```\r\n\r\n_TestChannelHandler:_\r\n```java\r\n@Channel(\"test\")\r\npublic class TestChannelHandler extends ChannelHandler<JSONObject> {\r\n\r\n    @Override\r\n    public void onMessage(String channel, JSONObject message) {\r\n\r\n        System.out.println(\"TestChannelHandler: foo=\" + message.get(\"foo\"));\r\n    }\r\n}\r\n```\r\n\r\n_BackendMultiChannelHandler:_\r\n```java\r\n@Channel(\"backend\")\r\npublic class BackendMultiChannelHandler {\r\n\r\n    @Key(\"role\")\r\n    @Value(\"update\")\r\n    public void onBackendRoleUpdate(JSONObject jsonObject) {\r\n\r\n\t\t// Keep in mind that the key (here \"role\") will be removed before invocation\r\n        System.out.println(\"BMCH[role=update]: ping=\" + jsonObject.getInt(\"ping\"));\r\n    }\r\n    \r\n    @Key(\"role\")\r\n    @Value(\"delete\")\r\n    public void onBackendRoleDelete(FooBar fooBar) {\r\n\r\n        System.out.println(\"FooBar[role=delete]: \" + fooBar.toString());\r\n    }\r\n}\r\n```\r\n\r\n_GsonChannelHandler:_\r\n```java\r\n@Channel(\"gson\")\r\npublic class GsonChannelHandler extends ChannelHandler<FooBar> {\r\n\r\n    @Override\r\n    public void onMessage(String channel, FooBar fooBar) {\r\n\r\n        System.out.println(\"FooBar class: \" + fooBar.toString());\r\n    }\r\n}\r\n```\r\n\r\n_The simple FooBar class:_\r\n```java\r\npublic class FooBar {\r\n\r\n\tprivate String foo;\r\n\r\n    public FooBar(String foo) {\r\n\r\n        this.foo = foo;\r\n    }\r\n\r\n\tpublic String getFoo() {\r\n\r\n        return foo;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n\r\n        return \"FooBar{\" +\r\n                \"foo='\" + foo + '\\'' +\r\n                '}';\r\n    }\r\n}\r\n```\r\n\r\n# PHP example\r\n\r\n_JaPSPublisher:_\r\n```php\r\n<?php\r\n\r\nclass JaPSPublisher\r\n{\r\n\r\n    /**\r\n     * Host address.\r\n     *\r\n     * @var string The host address.\r\n     */\r\n    private $host;\r\n\r\n    /**\r\n     * Host port.\r\n     *\r\n     * @var int The host port.\r\n     */\r\n    private $port;\r\n\r\n    /**\r\n     * Socket instance.\r\n     *\r\n     * @var resource The socket instance.\r\n     */\r\n    private $socket;\r\n\r\n    /**\r\n     * JaPSPublisher constructor.\r\n     */\r\n    /**\r\n     * JaPSPublisher constructor.\r\n     *\r\n     * @param string $host The host address to connect to.\r\n     * @param int $port The host port to connect to.\r\n     */\r\n    public function __construct($host = \"localhost\", $port = 1337)\r\n    {\r\n        $this->host = $host;\r\n        $this->port = $port;\r\n\r\n        $this->socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);\r\n\r\n        $this->connect();\r\n    }\r\n\r\n    /**\r\n     * Connects the internal socket.\r\n     */\r\n    private function connect() {\r\n\r\n        socket_connect($this->socket, $this->host, $this->port);\r\n    }\r\n\r\n    /**\r\n     * Publish a message to a given channel.\r\n     *\r\n     * @param ($channel) The channel.\r\n     * @param ($array) The message as an array which will be json encoded.\r\n     */\r\n    public function publish($channel, $array) {\r\n\r\n        $array['op'] = 2;\r\n        $array['ch'] = $channel;\r\n\r\n        $json = json_encode($array);\r\n        $jsonLength = strlen($json);\r\n        $length = pack('N', $jsonLength);\r\n\r\n        socket_write($this->socket, $length . $json, $jsonLength + 4);\r\n    }\r\n\r\n    /**\r\n     * Closes the publisher.\r\n     */\r\n    public function close() {\r\n\r\n        socket_close($this->socket);\r\n    }\r\n}\r\n```\r\n\r\n_Example usage:_\r\n```php\r\n<?php\r\n\r\ninclude(\"JaPSPublisher.php\");\r\n\r\n$client = new JaPSPublisher(\"192.168.2.102\", 6000);\r\n\r\n$client->publish(\"test\", array(\"foo\" => \"bar1\"));\r\n$client->publish(\"test\", array(\"foo\" => \"bar2\"));\r\n\r\n$client->close();\r\n```\r\n\r\n### License\r\n\r\nLicensed under the GNU General Public License, Version 3.0.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}